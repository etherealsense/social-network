// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: follows.sql

package repo

import (
	"context"
)

const countFollowers = `-- name: CountFollowers :one
SELECT COUNT(*) FROM follows WHERE following_id = $1
`

func (q *Queries) CountFollowers(ctx context.Context, followingID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countFollowers, followingID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFollowing = `-- name: CountFollowing :one
SELECT COUNT(*) FROM follows WHERE follower_id = $1
`

func (q *Queries) CountFollowing(ctx context.Context, followerID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countFollowing, followerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const followUser = `-- name: FollowUser :one
INSERT INTO follows (follower_id, following_id) VALUES ($1, $2) RETURNING id, follower_id, following_id, created_at
`

type FollowUserParams struct {
	FollowerID  int32 `json:"follower_id"`
	FollowingID int32 `json:"following_id"`
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (Follow, error) {
	row := q.db.QueryRow(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i Follow
	err := row.Scan(
		&i.ID,
		&i.FollowerID,
		&i.FollowingID,
		&i.CreatedAt,
	)
	return i, err
}

const listFollowers = `-- name: ListFollowers :many
SELECT id, follower_id, following_id, created_at FROM follows WHERE following_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListFollowersParams struct {
	FollowingID int32 `json:"following_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

func (q *Queries) ListFollowers(ctx context.Context, arg ListFollowersParams) ([]Follow, error) {
	rows, err := q.db.Query(ctx, listFollowers, arg.FollowingID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Follow
	for rows.Next() {
		var i Follow
		if err := rows.Scan(
			&i.ID,
			&i.FollowerID,
			&i.FollowingID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFollowing = `-- name: ListFollowing :many
SELECT id, follower_id, following_id, created_at FROM follows WHERE follower_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListFollowingParams struct {
	FollowerID int32 `json:"follower_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListFollowing(ctx context.Context, arg ListFollowingParams) ([]Follow, error) {
	rows, err := q.db.Query(ctx, listFollowing, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Follow
	for rows.Next() {
		var i Follow
		if err := rows.Scan(
			&i.ID,
			&i.FollowerID,
			&i.FollowingID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfollowUser = `-- name: UnfollowUser :exec
DELETE FROM follows WHERE follower_id = $1 AND following_id = $2
`

type UnfollowUserParams struct {
	FollowerID  int32 `json:"follower_id"`
	FollowingID int32 `json:"following_id"`
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) error {
	_, err := q.db.Exec(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	return err
}
